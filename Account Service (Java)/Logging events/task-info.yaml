type: edu
files:
  - name: src/account/AccountServiceApplication.java
    visible: true
    text: |
      package account;
      
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      
      @SpringBootApplication
      public class AccountServiceApplication {
      
          public static void main(String[] args) {
              SpringApplication.run(AccountServiceApplication.class, args);
          }
      
      }
    learner_created: false
  - name: src/resources/application.properties
    visible: true
    text: |-
      server.port=28852
      management.endpoints.web.exposure.include=*
      management.endpoint.shutdown.enabled=true
      spring.jackson.serialization.INDENT_OUTPUT=true
    learner_created: false
  - name: build.gradle
    visible: true
    text: |
      buildscript {
          apply plugin: 'hyperskill'
      
          repositories {
              mavenCentral()
          }
      
          dependencies {
              classpath "org.springframework.boot:spring-boot-gradle-plugin:$hs.spring.bootVersion"
              classpath "io.spring.gradle:dependency-management-plugin:$hs.spring.dependencyManagementVersion"
          }
      }
      
      apply plugin: 'java'
      apply plugin: 'org.springframework.boot'
      apply plugin: 'io.spring.dependency-management'
      
      repositories {
          mavenCentral()
      }
      
      sourceSets.main.resources.srcDirs = ["src/resources"]
      
      dependencies {
          implementation 'org.springframework.boot:spring-boot-starter'
          implementation 'org.springframework.boot:spring-boot-starter-actuator'
          implementation 'org.springframework.boot:spring-boot-starter-web'
          implementation 'com.h2database:h2'
          implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
      }
      
      test {
          jvmArgs '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
      }
    learner_created: false
  - name: test/AccountServiceTest.java
    visible: false
    text: |-
      import account.AccountServiceApplication;
      import com.fasterxml.jackson.annotation.JsonInclude;
      import com.fasterxml.jackson.core.JsonProcessingException;
      import com.fasterxml.jackson.databind.ObjectMapper;
      import com.google.gson.JsonArray;
      import com.google.gson.JsonElement;
      import com.google.gson.JsonObject;
      import com.google.gson.JsonParser;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.dynamic.input.DynamicTesting;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.mocks.web.request.HttpRequest;
      import org.hyperskill.hstest.mocks.web.response.HttpResponse;
      import org.hyperskill.hstest.stage.SpringTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.springframework.http.HttpStatus;
      
      import java.util.*;
      import java.util.stream.Collectors;
      
      import static org.hyperskill.hstest.common.JsonUtils.getJson;
      import static org.hyperskill.hstest.common.JsonUtils.getPrettyJson;
      import static org.hyperskill.hstest.testing.expect.Expectation.expect;
      import static org.hyperskill.hstest.testing.expect.json.JsonChecker.*;
      
      class TestReq {
      
        private Map<String, Object> properties = new LinkedHashMap<>();
      
        // Deep copy
        public TestReq(TestReq another) {
          this.properties = another.properties.entrySet().stream()
                  .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }
      
        public TestReq() {
        }
      
        public String toJson() {
          ObjectMapper mapper = new ObjectMapper();
          mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
          try {
            return mapper.writeValueAsString(this.properties);
          } catch (JsonProcessingException e) {
            System.out.println(e.getMessage());
            return null;
          }
        }
      
        public TestReq setProps(String key, Object value) {
          properties.put(key, value);
          return this;
        }
      
      }
      public class AccountServiceTest extends SpringTest {
      
        private  final String signUpApi = "/api/auth/signup";
        private  final String changePassApi = "/api/auth/changepass";
        private  final String getEmployeePaymentApi = "/api/empl/payment";
        private final String postPaymentApi = "/api/acct/payments";
        private final String putRoleApi = "/api/admin/user/role";
        private final String putAccessApi = "/api/admin/user/access";
        private final String adminApi = "/api/admin/user/";
        private final String auditorApi = "/api/security/events/";
      
        static String[] breachedPass= new String[]{"PasswordForJanuary", "PasswordForFebruary", "PasswordForMarch",
                "PasswordForApril", "PasswordForMay", "PasswordForJune",
                "PasswordForJuly", "PasswordForAugust", "PasswordForSeptember",
                "PasswordForOctober", "PasswordForNovember", "PasswordForDecember"};
      
        List<Integer> userIdList = new ArrayList<>();
      
        private final TestReq ivanIvanov = new TestReq().setProps("name", "Ivan")
                .setProps("lastname", "Ivanov")
                .setProps("email", "IvanIvanov@acme.com")
                .setProps("password", "rXoa4CvqpLxW");
        private final TestReq petrPetrov = new TestReq().setProps("name", "Petr")
                .setProps("lastname", "Petrov")
                .setProps("email", "PetrPetrov@acme.com")
                .setProps("password", "nWza98hjkLPE");
        private final TestReq johnDoe = new TestReq().setProps("name", "John")
                .setProps("lastname", "Doe")
                .setProps("email", "JohnDoe@acme.com")
                .setProps("password", "oMoa3VvqnLxW");
        private final TestReq maxMus = new TestReq().setProps("name", "Max")
                .setProps("lastname", "Mustermann")
                .setProps("email", "MaxMustermann@acme.com")
                .setProps("password", "ai0y9bMvyF6G");
        private final TestReq captainNemo = new TestReq().setProps("name", "Captain")
                .setProps("lastname", "Nemo")
                .setProps("email", "nautilus@pompilius.com")
                .setProps("password", "wings");
      
        private final String ivanIvanovCorrectUser = ivanIvanov.toJson();
        private final String petrPetrovCorrectUser = petrPetrov.toJson();
        private final String jDCorrectUser = johnDoe.toJson();
        private final String maxMusCorrectUser = maxMus.toJson();
        private final String maxMusLower = new TestReq(maxMus).setProps("email", "maxmustermann@acme.com").toJson();
        private final String maxMusWrongPassword = new TestReq(maxMus).setProps("password", "none").toJson();
        private final String petrPetrovWrongPassword = new TestReq(petrPetrov).setProps("password", "none").toJson();
        private final String maxMusWrongEmail = new TestReq(maxMus).setProps("email", "maxmustermann@google.com").toJson();
        private final String captainNemoWrongUser = captainNemo.toJson();
        private final String jDNewPass = new TestReq(johnDoe).setProps("password", "aNob5VvqzRtb").toJson();
        private final String jDPass = new TestReq().setProps("new_password", "aNob5VvqzRtb").toJson();
      
        private final String firstResponseAdminApi = convert(new String[]{
                new TestReq().setProps("id", 1).setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("email", "johndoe@acme.com").setProps("roles", new String[] {"ROLE_ADMINISTRATOR"}).toJson(),
                new TestReq().setProps("id", 2).setProps("name", "Ivan").setProps("lastname", "Ivanov")
                        .setProps("email", "ivanivanov@acme.com")
                        .setProps("roles", new String[] {"ROLE_AUDITOR", "ROLE_USER"}).toJson(),
                new TestReq().setProps("id", 3).setProps("name", "Max").setProps("lastname", "Mustermann")
                        .setProps("email", "maxmustermann@acme.com").setProps("roles", new String[] {"ROLE_USER"}).toJson()
        });
        private final String secondResponseAdminApi = convert(new String[]{
                new TestReq().setProps("id", 1).setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("email", "johndoe@acme.com").setProps("roles", new String[] {"ROLE_ADMINISTRATOR"}).toJson(),
                new TestReq().setProps("id", 2).setProps("name", "Ivan").setProps("lastname", "Ivanov")
                        .setProps("email", "ivanivanov@acme.com")
                        .setProps("roles", new String[] {"ROLE_AUDITOR", "ROLE_USER"}).toJson(),
                new TestReq().setProps("id", 3).setProps("name", "Max").setProps("lastname", "Mustermann")
                        .setProps("email", "maxmustermann@acme.com").setProps("roles", new String[] {"ROLE_USER"}).toJson(),
                new TestReq().setProps("id", 5).setProps("name", "Petr").setProps("lastname", "Petrov")
                        .setProps("email", "petrpetrov@acme.com").setProps("roles", new String[] {"ROLE_USER"}).toJson()
        });
      
        private String[] auditorResponseApi = new String[]{
                new TestReq().setProps("action", "CREATE_USER").setProps("subject", "Anonymous")
                        .setProps("object", "johndoe@acme.com").setProps("path", "/api/auth/signup").toJson(),
                new TestReq().setProps("action", "CREATE_USER").setProps("subject", "Anonymous")
                        .setProps("object", "ivanivanov@acme.com").setProps("path", "/api/auth/signup").toJson(),
                new TestReq().setProps("action", "GRANT_ROLE").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "Grant role AUDITOR to ivanivanov@acme.com").setProps("path", "/api/admin/user/role").toJson(),
                new TestReq().setProps("action", "CREATE_USER").setProps("subject", "Anonymous")
                        .setProps("object", "maxmustermann@acme.com").setProps("path", "/api/auth/signup").toJson(),
                new TestReq().setProps("action", "CREATE_USER").setProps("subject", "Anonymous")
                        .setProps("object", "petrpetrov@acme.com").setProps("path", "/api/auth/signup").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@google.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "nautilus@pompilius.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "GRANT_ROLE").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "Grant role ACCOUNTANT to petrpetrov@acme.com").setProps("path", "/api/admin/user/role").toJson(),
                new TestReq().setProps("action", "REMOVE_ROLE").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "Remove role ACCOUNTANT from petrpetrov@acme.com").setProps("path", "/api/admin/user/role").toJson(),
                new TestReq().setProps("action", "DELETE_USER").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "petrpetrov@acme.com").setProps("path", "/api/admin/user").toJson(),
                new TestReq().setProps("action", "CHANGE_PASSWORD").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "johndoe@acme.com").setProps("path", "/api/auth/changepass").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "ivanivanov@acme.com")
                        .setProps("object", "/api/admin/user/role").setProps("path", "/api/admin/user/role").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "ivanivanov@acme.com")
                        .setProps("object", "/api/admin/user").setProps("path", "/api/admin/user").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "ivanivanov@acme.com")
                        .setProps("object", "/api/admin/user").setProps("path", "/api/admin/user").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "/api/acct/payments").setProps("path", "/api/acct/payments").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/acct/payments").setProps("path", "/api/acct/payments").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "ACCESS_DENIED").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "/api/security/events").setProps("path", "/api/security/events").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "BRUTE_FORCE").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOCK_USER").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "Lock user maxmustermann@acme.com").setProps("path", "/api/admin/user/access").toJson(), // api !!!
                new TestReq().setProps("action", "UNLOCK_USER").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "Unlock user maxmustermann@acme.com").setProps("path", "/api/admin/user/access").toJson(), // api !!!
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "LOGIN_FAILED").setProps("subject", "maxmustermann@acme.com")
                        .setProps("object", "/api/empl/payment").setProps("path", "/api/empl/payment").toJson(),
                new TestReq().setProps("action", "UNLOCK_USER").setProps("subject", "johndoe@acme.com")
                        .setProps("object", "Unlock user maxmustermann@acme.com").setProps("path", "/api/admin/user/access").toJson()
        };
      
        public AccountServiceTest() {
          super(AccountServiceApplication.class, "../service_db.mv.db");
        }
      
        private String convert(String[] trs) {
          JsonArray  jsonArray = new JsonArray();
          for (String tr : trs) {
            JsonElement jsonObject = JsonParser.parseString(tr);
            jsonArray.add(jsonObject);
          }
          return jsonArray.toString();
        }
      
        CheckResult testApi(String user, String body, int status, String api, String method, String message) {
      
          HttpResponse response = checkResponseStatus(user, body, status, api, method, message);
      
      
          return CheckResult.correct();
        }
      
        /**
         * Method for checking response on Post request for signup API
         *
         * @param body string representation of body content in JSON format (String)
         * @param status required http status for response (int)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testPostSignUpResponse(String body, int status, String[] role) {
      
          HttpResponse response = checkResponseStatus(null, body, status, signUpApi, "POST", "");
      
          JsonObject rightResponse = getJson(body).getAsJsonObject();
          rightResponse.remove("password");
      
          // Check is it JSON in response or something else
          if (!response.getJson().isJsonObject()) {
            return CheckResult.wrong("Wrong object in response, expected JSON but was \n" +
                    response.getContent().getClass());
      
          }
      
          JsonObject jsonResponse = response.getJson().getAsJsonObject();
      
          // Check if password is presence in response
          if (jsonResponse.get("password") != null) {
            return CheckResult.wrong("You must remove password from response\n" +
                    jsonResponse);
          }
      
          if (jsonResponse.get("id") == null) {
            return CheckResult.wrong("Response must contain user ID\n" +
                    "Received response:\n" +
                    jsonResponse);
          }
      
      
      
          // Check JSON in response
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("id", isInteger())
                          .value("name", rightResponse.get("name").getAsString())
                          .value("lastname", rightResponse.get("lastname").getAsString())
                          .value("email", isString(s -> s.equalsIgnoreCase(rightResponse.get("email").getAsString())))
                          .value("roles", role));
      
          if (userIdList.contains(jsonResponse.get("id").getAsInt())) {
            return CheckResult.wrong("User ID must be unique!\n" +
                    "Received response:\n" +
                    jsonResponse);
          }
      
          userIdList.add(jsonResponse.get("id").getAsInt());
          return CheckResult.correct();
        }
      
        /**
         * Method for restarting application
         *
         */
        private CheckResult restartApplication() {
          try {
            reloadSpring();
          } catch (Exception ex) {
            throw new UnexpectedError(ex.getMessage());
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for checking authentication
         *
         * @param user string representation of user information in JSON format (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        private CheckResult testUserRegistration(String user, int status, String message) {
      
          HttpResponse response = checkResponseStatus(user, "", status, getEmployeePaymentApi, "GET", message);
      
          return CheckResult.correct();
        }
      
        CheckResult testChangePassword(String api, String body, int status, String user) {
          JsonObject userJson = getJson(user).getAsJsonObject();
      
          HttpResponse response = checkResponseStatus(user, body, status, api, "POST", "");
      
          // Check JSON in response
          if (status == 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("email", userJson.get("email").getAsString().toLowerCase())
                            .value("status", "The password has been updated successfully"));
          }
          return CheckResult.correct();
        }
      
        private CheckResult testGetAdminApi(String api, int status, String user, String answer, String message) {
      
          HttpResponse response = checkResponseStatus(user, "", status, api, "GET", message);
      
          // Check JSON in response
          if (response.getStatusCode() == 200) {
            // Check is it array of JSON in response or something else
            if (!response.getJson().isJsonArray()) {
              return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                      response.getContent().getClass());
            }
            JsonArray correctJson = getJson(answer).getAsJsonArray();
            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();
      
            if (responseJson.size() == 0)  {
              return CheckResult.wrong("No data in response body" + "\n"
                      + "in response " + getPrettyJson(responseJson)  + "\n"
                      + "must be " + getPrettyJson(correctJson));
            }
      
            if (responseJson.size() != correctJson.size())  {
              return CheckResult.wrong("No data in response body" + "\n"
                      + "in response " + getPrettyJson(responseJson)  + "\n"
                      + "must be " + getPrettyJson(correctJson));
            }
      
            for (int i = 0; i < responseJson.size(); i++) {
      
              String[] roles = new String[correctJson.get(i).getAsJsonObject().getAsJsonArray("roles").size()];
              for(int j=0; j<correctJson.get(i).getAsJsonObject().getAsJsonArray("roles").size(); j++) {
                roles[j]=correctJson.get(i).getAsJsonObject().getAsJsonArray("roles").get(j).getAsString();
              }
      
              expect(responseJson.get(i).getAsJsonObject().toString()).asJson()
                      .check(isObject()
                              .value("id", isInteger())
                              .value("name", correctJson.get(i).getAsJsonObject().get("name").getAsString())
                              .value("lastname", correctJson.get(i).getAsJsonObject().get("lastname").getAsString())
                              .value("email", correctJson.get(i).getAsJsonObject().get("email").getAsString())
                              .value("roles", isArray( roles )));
            }
          }
          return CheckResult.correct();
        }
      
        CheckResult testPutAdminApi(String api, HttpStatus status, String user, String reqUser,
                                    String role, String operation, String[] respRoles, String message) {
      
          JsonObject jsonUser = getJson(reqUser).getAsJsonObject();
          JsonObject request = new JsonObject();
          request.addProperty("user", jsonUser.get("email").getAsString());
          request.addProperty("operation", operation);
          request.addProperty("role", role);
      
          HttpResponse response = checkResponseStatus(user, request.toString(), status.value(), api, "PUT", message);
      
          // Check JSON in response
          if (response.getStatusCode() == 200) {
            expect(response.getContent()).asJson()
                    .check(isObject()
                            .value("id", isInteger())
                            .value("name", jsonUser.get("name").getAsString())
                            .value("lastname", jsonUser.get("lastname").getAsString())
                            .value("email", jsonUser.get("email").getAsString().toLowerCase())
                            .value("roles", isArray(respRoles)));
          }
      
          if (response.getStatusCode() != 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("error", status.getReasonPhrase())
                            .value("path", api)
                            .value("status", status.value())
                            .value("message", respRoles[0])
                            .anyOtherValues());
          }
          return CheckResult.correct();
        }
      
        CheckResult testPutAccessApi(String api, HttpStatus status, String user, String reqUser,
                                     String operation, String answer, String message) {
      
          JsonObject jsonUser = getJson(reqUser).getAsJsonObject();
          JsonObject request = new JsonObject();
          request.addProperty("user", jsonUser.get("email").getAsString());
          request.addProperty("operation", operation);
      
          HttpResponse response = checkResponseStatus(user, request.toString(), status.value(), api, "PUT", message);
      
          // Check JSON in response
      
          if (response.getStatusCode() == 200) {
            expect(response.getContent()).asJson()
                    .check(isObject()
                            .value("status", answer));
          } else {
            expect(response.getContent()).asJson()
                    .check(isObject()
                            .value("error", status.getReasonPhrase())
                            .value("path", api)
                            .value("status", status.value())
                            .value("message", answer)
                            .anyOtherValues());
          }
      
      
          return CheckResult.correct();
        }
      
        CheckResult testLocking(String api, HttpStatus status, String user, String answer, String message) {
      
          HttpResponse response = checkResponseStatus(user, "", status.value(), api, "GET", message);
      
          // Check JSON in response
          if (response.getStatusCode() != 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("error", status.getReasonPhrase())
                            .value("path", api)
                            .value("status", status.value())
                            .value("message", answer)
                            .anyOtherValues());
          }
          return CheckResult.correct();
        }
      
        CheckResult testRoleModelNegative(String api, String method, HttpStatus status, String user, String body, String message) {
      
          HttpResponse response = checkResponseStatus(user, body, status.value(), api, method.toUpperCase(), message);
      
          // Check JSON in response
          if (response.getStatusCode() != 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("error", status.getReasonPhrase())
                            .value("path", api)
                            .value("status", status.value())
                            .value("message", "Access Denied!")
                            .anyOtherValues());
          }
          return CheckResult.correct();
        }
      
        private CheckResult testAuditorApi(String api, int status, String user, String answer,
                                           int position, String message) {
      
          HttpResponse response = checkResponseStatus(user, "", status, api, "GET", message);
      
          // Check is it array of JSON in response or something else
          if (!response.getJson().isJsonArray()) {
            return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                    response.getContent().getClass());
      
          }
      
          JsonArray correctJson = getJson(answer).getAsJsonArray();
          JsonArray responseJson = null;
          try {
            responseJson = getJson(response.getContent()).getAsJsonArray();
          } catch (Exception e) {
            return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                    response.getContent().getClass());
          }
          if (responseJson.isEmpty()) {
            throw new WrongAnswer("Empty array in response!");
          }
      
          if (responseJson.size() != correctJson.size()) {
            throw new WrongAnswer("Incorrect number - " +  responseJson.size() +
                    " events in response, must be - " + correctJson.size() + "\n" +
                    "response:\n" + getPrettyJson(responseJson)  + "\n" +
                    "must be:\n " + getPrettyJson(correctJson));
          }
      
          // Check JSON in response
          if (response.getStatusCode() == 200) {
            expect(responseJson.get(position).toString()).asJson().check(
                    isObject()
                            .value("action", correctJson.get(position).getAsJsonObject().get("action").getAsString())
                            .value("subject", correctJson.get(position).getAsJsonObject().get("subject").getAsString())
                            .value("object", isString( o -> o.contains(correctJson.get(position).getAsJsonObject().get("object").getAsString())))
                            .value("path", isString())
                            .anyOtherValues());
      
          }
          return CheckResult.correct();
        }
      
        CheckResult testDeleteAdminApi(String api, HttpStatus status, String user, String param,
                                       String answer, String message) {
      
          HttpResponse response = checkResponseStatus(user, "", status.value(),
                  api + param, "DELETE", message);
      
          // Check JSON in response
          if (response.getStatusCode() == 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("user", param.toLowerCase())
                            .value("status", answer));
          }
      
          if (response.getStatusCode() != 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("error", status.getReasonPhrase())
                            .value("path", api + param)
                            .value("status", status.value())
                            .value("message", answer)
                            .anyOtherValues());
          }
          return CheckResult.correct();
        }
      
      
        /**
         * Method for testing api response
         *
         * @param user string representation of user information in JSON format (String)
         * @param body request body (String)
         * @param status expected response status (int)
         * @param api testing api (String)
         * @param method method for api (String)
         * @param message test hints for student (String)
         * @return response (HttpResponse)
         */
        private HttpResponse checkResponseStatus(String user, String body,
                                                 int status, String api, String method, String message) {
          HttpRequest request = null;
          switch (method) {
            case "GET":
              request = get(api);
              break;
            case "POST":
              request = post(api, body);
              break;
            case "PUT":
              request = put(api, body);
              break;
            case "DELETE":
              request = delete(api);
              break;
          }
      
          if (user != null) {
            JsonObject userJson = getJson(user).getAsJsonObject();
            String password = userJson.get("password").getAsString();
            String login = userJson.get("email").getAsString().toLowerCase();
            request = request.basicAuth(login, password);
          }
          HttpResponse response = request.send();
      
          if (response.getStatusCode() != status) {
            throw new WrongAnswer(method + " " + api  + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message + "\n"
                    + "Response body:\n" + response.getContent() + "\n");
          }
          return response;
        }
      
        private String getSub (String[] src, int position) {
          return convert(Arrays.copyOfRange(src, 0, position));
        }
      
        @DynamicTest
        DynamicTesting[] dt = new DynamicTesting[] {
      
                // Create administrator and auditor
                () -> testPostSignUpResponse(jDCorrectUser, 200, new String[] {"ROLE_ADMINISTRATOR"}), // 1
                () -> testPostSignUpResponse(ivanIvanovCorrectUser, 200, new String[] {"ROLE_USER"}), // 2
                () -> testPutAdminApi(putRoleApi, HttpStatus.OK, jDCorrectUser,
                        ivanIvanovCorrectUser, "AUDITOR", "GRANT",
                        new String[] {"ROLE_AUDITOR", "ROLE_USER"}, ""), // 3
      
                // Testing user registration positive tests
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 3), 0,"'CREATE_USER' security event missing"), // 4
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 3), 1,"'CREATE_USER' security event missing"), // 5
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 3), 2,"'GRANT_ROLE' security event missing"), // 6
                () -> testPostSignUpResponse(maxMusLower, 200, new String[] {"ROLE_USER"}), // 7
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 4), 3,"'CREATE_USER' security event missing"), // 8
                () -> testPostSignUpResponse(petrPetrovCorrectUser, 200, new String[] {"ROLE_USER"}), // 9
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 5), 4,"'CREATE_USER' security event missing"), // 10
      
      //
      //          // Test authentication, positive tests
                () -> testUserRegistration(maxMusLower, 200, "User must login!"), // 11
                () -> testUserRegistration(maxMusCorrectUser, 200, "Login case insensitive!"), // 12
      //
      //          // Test authentication, negative tests
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 13
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 6), 5,"'LOGIN_FAILED' security event missing"), // 14
                () -> testUserRegistration(maxMusWrongEmail, 401, "Wrong password!"), // 15
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 7), 6,"'LOGIN_FAILED' security event missing"), // 16
                () -> testUserRegistration(captainNemoWrongUser, 401, "Wrong user"), // 17
                () -> testApi(null, "", 401, getEmployeePaymentApi, "GET",
                        "This api only for authenticated user"), // 18
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 8), 7,"'LOGIN_FAILED' security event missing"), // 19
      
      //          // Testing persistence
                () -> restartApplication(), // 20
                () -> testUserRegistration(maxMusCorrectUser, 200, "User must login, after restarting!" +
                        " Check persistence."), // 21
      
                // Changing roles
                () -> testPutAdminApi(putRoleApi, HttpStatus.BAD_REQUEST, jDCorrectUser,
                        jDCorrectUser, "AUDITOR", "GRANT",
                        new String[] {"The user cannot combine administrative and business roles!"},
                        "Trying add administrative role to business user!"), // 22
                () -> testPutAdminApi(putRoleApi, HttpStatus.OK, jDCorrectUser,
                        petrPetrovCorrectUser, "ACCOUNTANT", "GRANT",
                        new String[] {"ROLE_ACCOUNTANT", "ROLE_USER"}, "Trying to add role ACCOUNTANT to user"), // 23
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 9), 8,"'GRANT_ROLE' security event missing"), // 24
                () -> testPutAdminApi(putRoleApi, HttpStatus.OK, jDCorrectUser,
                        petrPetrovCorrectUser, "ACCOUNTANT", "REMOVE",
                        new String[] {"ROLE_USER"}, "Trying to remove role ACCOUNTANT from user"), // 25
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 10), 9,"'REMOVE_ROLE' security event missing"), // 26
      
                //Delete user
                () -> testDeleteAdminApi("/api/admin/user/", HttpStatus.OK, jDCorrectUser,
                        "petrpetrov@acme.com", "Deleted successfully!", "Trying to delete user"), // 27
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 11), 10,"'DELETE_USER' security event missing"), // 28
      
                // Change password
                () -> testChangePassword(changePassApi, jDPass, 200, jDCorrectUser), // 29
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 12), 11,"'CHANGE_PASSWORD' security event missing"), // 30
      
                // Testing role model negative case
                () -> testRoleModelNegative(putRoleApi, "PUT", HttpStatus.FORBIDDEN, ivanIvanovCorrectUser,
                        "", "Trying to access administrative endpoint with business user"), // 31
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 13), 12,"'ACCESS_DENIED' security event missing"), // 32
                () -> testRoleModelNegative(adminApi, "GET", HttpStatus.FORBIDDEN, ivanIvanovCorrectUser,
                        "", "Trying to access administrative endpoint with business user"), // 33
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 14), 13,"'ACCESS_DENIED' security event missing"), // 34
                () -> testRoleModelNegative(adminApi, "DELETE", HttpStatus.FORBIDDEN, ivanIvanovCorrectUser,
                        "", "Trying to access administrative endpoint with business user"), // 35
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 15), 14,"'ACCESS_DENIED' security event missing"), // 36
                () -> testRoleModelNegative(postPaymentApi, "POST", HttpStatus.FORBIDDEN, jDNewPass,
                        "", "Trying to access business endpoint with administrative user"), // 37
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 16), 15,"'ACCESS_DENIED' security event missing"), // 38
                () -> testRoleModelNegative(postPaymentApi, "POST", HttpStatus.FORBIDDEN, maxMusCorrectUser,
                        "", "Trying to access endpoint with wrong role"), // 39
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 17), 16,"'ACCESS_DENIED' security event missing"), // 40
                () -> testRoleModelNegative(getEmployeePaymentApi, "GET", HttpStatus.FORBIDDEN, jDNewPass,
                        "", "Trying to access business endpoint with administrative user"), // 41
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 18), 17,"'ACCESS_DENIED' security event missing"), // 42
      
                () -> testRoleModelNegative(auditorApi, "GET", HttpStatus.FORBIDDEN, jDNewPass,
                        "", "Trying to access business endpoint with administrative user"), // 43
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 19), 18,"'ACCESS_DENIED' security event missing"), // 44
      
                // Testing locking user
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 45
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 20), 19,"'LOGIN_FAILED' security event missing"), // 46
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 47
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 21), 20,"'LOGIN_FAILED' security event missing"), // 48
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 49
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 22), 21,"'LOGIN_FAILED' security event missing"), // 50
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 51
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 23), 22,"'LOGIN_FAILED' security event missing"), // 52
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 53
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 26), 23,"'LOGIN_FAILED' security event missing"), // 54
                () -> testLocking(getEmployeePaymentApi, HttpStatus.UNAUTHORIZED, maxMusCorrectUser,
                        "User account is locked", "User must be locked after 5 attempts with wrong password"), // 55
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 26), 24,"'BRUTE_FORCE' security event missing"), // 56
                () -> testPutAccessApi(putAccessApi, HttpStatus.OK, jDNewPass,
                        maxMusCorrectUser,"UNLOCK",
                        "User maxmustermann@acme.com unlocked!", "User must be unlocked through admin endpoint"), // 57
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 27), 25,"'LOCK_USER' security event missing"), // 58
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 27), 26,"'UNLOCK_USER' security event missing"), // 59
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 60
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 28), 27,"'LOGIN_FAILED' security event missing"), // 61
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 62
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 29), 28,"'LOGIN_FAILED' security event missing"), // 63
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 64
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 30), 29,"'LOGIN_FAILED' security event missing"), // 65
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 66
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 31), 30,"'LOGIN_FAILED' security event missing"), // 67
                () -> testUserRegistration(maxMusCorrectUser, 200, "User must login!"), // 68
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 69
                () -> testUserRegistration(maxMusCorrectUser, 200,
                        "Counter of failed login attempts must be reset after successfully login!"), // 70
                () -> testPutAccessApi(putAccessApi, HttpStatus.OK, jDNewPass,
                        maxMusCorrectUser,"LOCK",
                        "User maxmustermann@acme.com locked!", ""), // 71
                () -> testAuditorApi(auditorApi, 200, ivanIvanovCorrectUser,
                        getSub(auditorResponseApi, 33), 31,"'LOCK_USER' security event missing"), // 72
                () -> testLocking(getEmployeePaymentApi, HttpStatus.UNAUTHORIZED, maxMusCorrectUser,
                        "User account is locked", "User must be locked through admin endpoint"), // 72
                () -> testPutAccessApi(putAccessApi, HttpStatus.BAD_REQUEST, jDNewPass,
                        jDCorrectUser,"LOCK",
                        "Can't lock the ADMINISTRATOR!", ""),
                () -> testGetAdminApi(adminApi, 200, jDNewPass,
                        firstResponseAdminApi, "Api must be available to admin user"),
      
                () -> testPostSignUpResponse(petrPetrovCorrectUser, 200, new String[] {"ROLE_USER"}),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovCorrectUser, 200,
                        "User must be locked only after 5 attempts with wrong password"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovCorrectUser, 200,
                        "In case of a successful login, reset the counter of the failed attempt."),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(petrPetrovWrongPassword, 401, "Wrong password!"),
                () -> testLocking(getEmployeePaymentApi, HttpStatus.UNAUTHORIZED, petrPetrovCorrectUser,
                        "User account is locked", "User must be locked after 5 attempts with wrong password!"),
                () -> testGetAdminApi(adminApi, 401, jDCorrectUser,
                        firstResponseAdminApi, "Wrong password for admin"),
                () -> testGetAdminApi(adminApi, 401, jDCorrectUser,
                        firstResponseAdminApi, "Wrong password for admin"),
                () -> testGetAdminApi(adminApi, 401, jDCorrectUser,
                        firstResponseAdminApi, "Wrong password for admin"),
                () -> testGetAdminApi(adminApi, 401, jDCorrectUser,
                        firstResponseAdminApi, "Wrong password for admin"),
                () -> testGetAdminApi(adminApi, 401, jDCorrectUser,
                        firstResponseAdminApi, "Wrong password for admin"),
                () -> testGetAdminApi(adminApi, 200, jDNewPass,
                        secondResponseAdminApi, "Api must be available to admin user")
        };
      
      }
    learner_created: false
  - name: src/account/AccountService.java
    visible: true
    text: |
      package account;
      
      import account.exceptions.*;
      import account.payroll.Payroll;
      import account.payroll.PayrollID;
      import account.payroll.PayrollRepository;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;
      
      import java.time.LocalDate;
      import java.util.List;
      import java.util.Optional;
      
      @Service
      public class AccountService {
          private final UserRepository userRepository;
          private final PayrollRepository payrollRepository;
          private final GroupRepository groupRepository;
          private final PasswordEncoder passwordEncoder;
      
          public AccountService(UserRepository userRepository, PayrollRepository payrollRepository, GroupRepository groupRepository, PasswordEncoder passwordEncoder) {
              this.userRepository = userRepository;
              this.payrollRepository = payrollRepository;
              this.groupRepository = groupRepository;
              this.passwordEncoder = passwordEncoder;
          }
      
          public AccountUser getUserFromEmail(String email) {
              return userRepository.findUserByEmailIgnoreCase(email).orElse(null);
          }
      
          public AccountUser addUser(AccountUser user) {
              if (userRepository.findUserByEmailIgnoreCase(user.getEmail()).isPresent()) {
                  throw new UserAlreadyExistsException();
              }
      
              user.setEmail(user.getEmail().toLowerCase());
              user.setPassword(passwordEncoder.encode(user.getPassword()));
      
              boolean isAdministratorAlreadyAdded = groupRepository.getAdminGroup().getUsersInGroup().size() == 1;
      
              if (isAdministratorAlreadyAdded) {
                  Group users = groupRepository.getUserGroup();
                  users.getUsersInGroup().add(user);
                  user.getRoles().add(users);
                  groupRepository.save(users);
              } else {
                  Group admin = groupRepository.getAdminGroup();
                  admin.getUsersInGroup().add(user);
                  user.getRoles().add(admin);
                  groupRepository.save(admin);
              }
      
              return getUserFromEmail(user.getEmail());
          }
      
          public void changeUserPassword(String email, String newPassword) {
              AccountUser user = getUserFromEmail(email);
      
              if (passwordEncoder.matches(newPassword, user.getPassword())) {
                  throw new SamePasswordException();
              }
      
              user.setPassword(passwordEncoder.encode(newPassword));
              userRepository.save(user);
          }
      
          @Transactional
          public void addPayrolls(List<Payroll> payrolls) {
              payrolls.forEach(payroll -> {
                  if (payroll.getSalary() < 0) {
                      throw new NegativeSalaryException();
                  }
      
                  if (getUserFromEmail(payroll.getEmployee()) == null) {
                      throw new UserDoesNotExistException();
                  }
      
                  payroll.setEmployee(payroll.getEmployee().toLowerCase());
      
                  if (payrollRepository.existsById(new PayrollID(payroll.getEmployee(), payroll.getPeriod()))) {
                      throw new PayrollAlreadyExistsException();
                  }
      
                  payrollRepository.save(payroll);
              });
          }
      
          public void updatePayroll(Payroll payroll) {
              if (payroll.getSalary() < 0) {
                  throw new NegativeSalaryException();
              }
      
              if (getUserFromEmail(payroll.getEmployee()) == null) {
                  throw new UserDoesNotExistException();
              }
      
              Payroll updatedPayroll = payrollRepository.findById(new PayrollID(payroll.getEmployee().toLowerCase(), payroll.getPeriod())).get();
      
              updatedPayroll.setSalary(payroll.getSalary());
              payrollRepository.save(updatedPayroll);
          }
      
      
          public Optional<Payroll> getPayrollForUser(String email, LocalDate period) {
              return payrollRepository.findById(new PayrollID(email, period));
          }
      
          public List<Payroll> getAllPayrollsForUser(String email) {
              return payrollRepository.getPayrollsByEmployeeIgnoreCaseOrderByPeriodDesc(email);
          }
      
          public List<AccountUser> getUsers() {
              return userRepository.getAllUsersWithAscendingIds();
          }
      
          public void deleteUser(String email) {
              AccountUser user = getUserFromEmail(email);
      
              if (user.getRoles().contains(groupRepository.getAdminGroup())) {
                  throw new DeleteAdminException("/api/admin/user/" + email);
              }
      
              List<Group> groups = groupRepository.findGroupsByUsersInGroupContains(user);
      
              groups.forEach(g -> {
                  g.getUsersInGroup().remove(user);
                  user.getRoles().remove(g);
                  groupRepository.save(g);
              });
      
              userRepository.delete(user);
          }
      
          public AccountUser changeUserRole(String email, Group.Role role, String operation) {
              AccountUser user = getUserFromEmail(email);
      
              if (user == null) {
                  throw new UserNotFoundException("/api/admin/user/role");
              }
      
              Group group = switch (role) {
                  case ADMINISTRATOR -> groupRepository.getAdminGroup();
                  case USER -> groupRepository.getUserGroup();
                  case ACCOUNTANT -> groupRepository.getAccountantGroup();
              };
      
              if (operation.equals("GRANT")) {
                  if (user.getRolesAsEnumSet().contains(Group.Role.ADMINISTRATOR) && (role == Group.Role.ACCOUNTANT || role == Group.Role.USER)) {
                      throw new CombineAdminBusinessRoleException();
                  } else if ((user.getRolesAsEnumSet().contains(Group.Role.ACCOUNTANT) || user.getRolesAsEnumSet().contains(Group.Role.USER)) && role == Group.Role.ADMINISTRATOR) {
                      throw new CombineAdminBusinessRoleException();
                  }
      
                  group.getUsersInGroup().add(user);
                  user.getRoles().add(group);
              } else {
                  if (!user.getRolesAsEnumSet().contains(role)) {
                      throw new UserDoesNotHaveRoleException();
                  }
      
                  if (user.getRolesAsEnumSet().contains(Group.Role.ADMINISTRATOR)) {
                      throw new DeleteAdminRoleException();
                  }
      
                  if (user.getRoles().size() == 1) {
                      throw new DeleteUserOnlyRoleException();
                  }
      
                  group.getUsersInGroup().remove(user);
                  user.getRoles().remove(group);
              }
      
              groupRepository.save(group);
      
              return user;
          }
      }
    learner_created: true
  - name: src/account/exceptions/UserAlreadyExistsException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserAlreadyExistsException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/RoleNotFoundException.java
    visible: true
    text: |-
      package account.exceptions;
      
      public class RoleNotFoundException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/DeleteUserOnlyRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class DeleteUserOnlyRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/PayrollAlreadyExistsException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class PayrollAlreadyExistsException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/UserDoesNotHaveRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserDoesNotHaveRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/PasswordTooShortException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class PasswordTooShortException extends RuntimeException {
          private final String path;
      
          public PasswordTooShortException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/ErrorMessage.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Data;
      import org.springframework.http.HttpStatus;
      
      import java.time.LocalDateTime;
      
      @Data
      public class ErrorMessage {
          public ErrorMessage(LocalDateTime timestamp, HttpStatus status, String error, String message, String path) {
              this.timestamp = timestamp;
              this.status = status.value();
              this.error = error;
              this.message = message;
              this.path = path;
          }
      
          private LocalDateTime timestamp;
          private int status;
          private String error;
          private String message;
          private String path;
      }
    learner_created: true
  - name: src/account/payroll/Payroll.java
    visible: true
    text: |
      package account.payroll;
      
      import com.fasterxml.jackson.annotation.JsonCreator;
      import com.fasterxml.jackson.annotation.JsonProperty;
      import jakarta.persistence.Entity;
      import jakarta.persistence.Id;
      import jakarta.persistence.IdClass;
      import jakarta.persistence.Table;
      import jakarta.validation.constraints.NotNull;
      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      import java.time.LocalDate;
      
      @Entity
      @Table(name = "payrolls")
      @IdClass(PayrollID.class)
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class Payroll {
          @Id
          @NotNull
          private String employee;
          @Id
          @NotNull
          private LocalDate period;
          @NotNull
          private long salary;
      
          @JsonCreator
          public Payroll(@JsonProperty("employee") String employee, @JsonProperty("period") String period, @JsonProperty("salary") long salary) {
              this.employee = employee;
              String[] periodParts = period.split("-");
              int month = Integer.parseInt(periodParts[0]);
              int year = Integer.parseInt(periodParts[1]);
              this.period = LocalDate.of(year, month, 1);
              this.salary = salary;
          }
      }
    learner_created: true
  - name: src/account/exceptions/DeleteAdminRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class DeleteAdminRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/AccountRestController.java
    visible: true
    text: |
      package account;
      
      import account.exceptions.*;
      import account.payroll.Payroll;
      import jakarta.validation.Valid;
      import jakarta.validation.constraints.NotNull;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.http.converter.HttpMessageConversionException;
      import org.springframework.security.core.Authentication;
      import org.springframework.web.bind.annotation.*;
      
      import java.time.LocalDate;
      import java.time.LocalDateTime;
      import java.time.format.TextStyle;
      import java.util.List;
      import java.util.Locale;
      
      @RestController
      public class AccountRestController {
          private final AccountService accountService;
      
          public AccountRestController(AccountService accountService) {
              this.accountService = accountService;
          }
      
          public UserResponse formatUserAsResponse(AccountUser user) {
              return new UserResponse(user.getId(), user.getName(), user.getLastname(), user.getEmail(), user.getFormattedAndSortedRolesAsStrings());
          }
      
          @PostMapping("api/auth/signup")
          public ResponseEntity<UserResponse> signupUser(@Valid @RequestBody AccountUser user) {
              if (PasswordUtils.isPasswordTooShort(user.getPassword())) {
                  throw new PasswordTooShortException("/api/auth/signup");
              }
      
              if (PasswordUtils.isBreachedPassword(user.getPassword())) {
                  throw new BreachedPasswordException("/api/auth/signup");
              }
              user = accountService.addUser(user);
              return ResponseEntity.ok(formatUserAsResponse(user));
          }
      
          @PostMapping("api/auth/changepass")
          public ResponseEntity<UpdatedPasswordResponse> changePassword(@Valid @RequestBody ChangePasswordRequest request, Authentication auth) {
              if (PasswordUtils.isPasswordTooShort(request.new_password)) {
                  throw new PasswordTooShortException("/api/auth/changepass");
              }
      
              if (PasswordUtils.isBreachedPassword(request.new_password)) {
                  throw new BreachedPasswordException("/api/auth/changepass");
              }
      
              accountService.changeUserPassword(auth.getName(), request.new_password);
      
              return ResponseEntity.ok(new UpdatedPasswordResponse(auth.getName(), "The password has been updated successfully"));
          }
      
      
          @PostMapping("api/acct/payments")
          public ResponseEntity<PayrollStatusResponse> uploadPayrolls(@RequestBody List<Payroll> payrolls) {
              accountService.addPayrolls(payrolls);
      
              return ResponseEntity.ok(new PayrollStatusResponse("Added successfully!"));
          }
      
          @PutMapping("api/acct/payments")
          public ResponseEntity<PayrollStatusResponse> updatePayroll(@RequestBody Payroll payroll) {
              accountService.updatePayroll(payroll);
      
              return ResponseEntity.ok(new PayrollStatusResponse("Updated successfully!"));
          }
      
          @ExceptionHandler(HttpMessageConversionException.class)
          public ResponseEntity<ErrorMessage> handleInvalidPeriod(HttpMessageConversionException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Period month is invalid!", "/api/acct/payments"));
          }
      
          public PayrollResponse formatPayrollAsResponse(Payroll payroll) {
              if (payroll == null) {
                  return null;
              }
              String period = payroll.getPeriod().getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH) + "-" + payroll.getPeriod().getYear();
              long dollars = payroll.getSalary() / 100;
              long cents = payroll.getSalary() % 100;
              String salary = dollars + " dollar(s) " + cents + " cent(s)";
              AccountUser user = accountService.getUserFromEmail(payroll.getEmployee());
              return new PayrollResponse(user.getName(), user.getLastname(), period, salary);
          }
      
          @GetMapping("api/empl/payment")
          public ResponseEntity<Object> getPayrolls(@RequestParam(required = false, name = "period") String periodString, Authentication auth) {
              if (periodString == null) {
                  return ResponseEntity.ok(accountService.getAllPayrollsForUser(auth.getName()).stream().map(this::formatPayrollAsResponse).toList());
              } else {
                  String[] periodParts = periodString.split("-");
                  int month = Integer.parseInt(periodParts[0]);
                  int year = Integer.parseInt(periodParts[1]);
      
                  if (month < 1 || month > 12) {
                      throw new InvalidPeriodException();
                  }
      
                  return ResponseEntity.ok(formatPayrollAsResponse(accountService.getPayrollForUser(auth.getName(), LocalDate.of(year, month, 1)).orElse(null)));
              }
          }
      
          @GetMapping("api/admin/user/")
          public ResponseEntity<List<UserResponse>> getUsers() {
              return ResponseEntity.ok(accountService.getUsers().stream().map(this::formatUserAsResponse).toList());
          }
      
          @DeleteMapping("api/admin/user/{email}")
          public ResponseEntity<DeletedUserResponse> deleteUser(@PathVariable String email) {
              if (accountService.getUserFromEmail(email) == null) {
                  throw new UserNotFoundException("/api/admin/user/" + email);
              }
      
              accountService.deleteUser(email);
      
              return ResponseEntity.ok(new DeletedUserResponse(email, "Deleted successfully!"));
      
          }
      
          @PutMapping("api/admin/user/role")
          public ResponseEntity<UserResponse> changeRoles(@RequestBody ChangeRoleRequest request) {
              if (!request.role.matches("(ADMINISTRATOR)|(ACCOUNTANT)|(USER)")) {
                  throw new RoleNotFoundException();
              }
      
              Group.Role role = switch (request.role) {
                  case "ADMINISTRATOR" -> Group.Role.ADMINISTRATOR;
                  case "ACCOUNTANT" -> Group.Role.ACCOUNTANT;
                  default -> Group.Role.USER;
              };
      
              return ResponseEntity.ok(formatUserAsResponse(accountService.changeUserRole(request.user, role, request.operation)));
          }
      
          public record UserResponse(long id, String name, String lastname, String email, String[] roles) {
          }
      
          public record ChangePasswordRequest(@NotNull String new_password) {
          }
      
          public record UpdatedPasswordResponse(String email, String status) {
          }
      
          public record PayrollStatusResponse(String status) {
          }
      
          public record PayrollResponse(String name, String lastname, String period, String salary) {
          }
      
          public record DeletedUserResponse(String user, String status) {
          }
      
          public record ChangeRoleRequest(String user, String role, String operation) {
          }
      }
    learner_created: true
  - name: src/account/exceptions/DeleteAdminException.java
    visible: true
    text: |-
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class DeleteAdminException extends RuntimeException {
      
          private final String path;
      
          public DeleteAdminException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/UserNotFoundException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class UserNotFoundException extends RuntimeException {
      
          private final String path;
      
          public UserNotFoundException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/InvalidPeriodException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class InvalidPeriodException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/UserDoesNotExistException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserDoesNotExistException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/payroll/PayrollRepository.java
    visible: true
    text: |
      package account.payroll;
      
      import org.springframework.data.repository.CrudRepository;
      
      import java.util.List;
      
      public interface PayrollRepository extends CrudRepository<Payroll, PayrollID> {
          List<Payroll> getPayrollsByEmployeeIgnoreCaseOrderByPeriodDesc(String employee);
      
          List<Payroll> getAllByEmployee(String employee);
      }
    learner_created: true
  - name: src/account/payroll/PayrollID.java
    visible: true
    text: |
      package account.payroll;
      
      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      import java.io.Serializable;
      import java.time.LocalDate;
      
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class PayrollID implements Serializable {
          private String employee;
          private LocalDate period;
      }
    learner_created: true
  - name: src/account/exceptions/CombineAdminBusinessRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class CombineAdminBusinessRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/AccountExceptionHandler.java
    visible: true
    text: |
      package account.exceptions;
      
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.ControllerAdvice;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
      
      import java.time.LocalDateTime;
      
      @ControllerAdvice
      public class AccountExceptionHandler extends ResponseEntityExceptionHandler {
          @ExceptionHandler(UserAlreadyExistsException.class)
          public ResponseEntity<ErrorMessage> handleUserAlreadyExists() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "User exist!", "/api/auth/signup"));
          }
      
          @ExceptionHandler(PasswordTooShortException.class)
          public ResponseEntity<ErrorMessage> handlePasswordTooShort(PasswordTooShortException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Password length must be 12 chars minimum!", e.getPath()));
          }
      
          @ExceptionHandler(BreachedPasswordException.class)
          public ResponseEntity<ErrorMessage> handleBreachedPassword(BreachedPasswordException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The password is in the hacker's database!", e.getPath()));
          }
      
          @ExceptionHandler(SamePasswordException.class)
          public ResponseEntity<ErrorMessage> handleSamePassword() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The passwords must be different!", "/api/auth/changepass"));
          }
      
          @ExceptionHandler(NegativeSalaryException.class)
          public ResponseEntity<ErrorMessage> handleNegativeSalary() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Salary cannot be negative for a payroll period!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(UserDoesNotExistException.class)
          public ResponseEntity<ErrorMessage> handleUserDoesNotExist() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Pay roll user does not exist!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(PayrollAlreadyExistsException.class)
          public ResponseEntity<ErrorMessage> handlePayrollAlreadyExists() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Payroll exist!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(InvalidPeriodException.class)
          public ResponseEntity<ErrorMessage> handleInvalidPeriod() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Period month is invalid!", "/api/empl/payment"));
          }
      
          @ExceptionHandler(UserNotFoundException.class)
          public ResponseEntity<ErrorMessage> handleUserNotFound(UserNotFoundException e) {
              return new ResponseEntity<>(new ErrorMessage(LocalDateTime.now(), HttpStatus.NOT_FOUND, "Not Found", "User not found!", e.getPath()), HttpStatus.NOT_FOUND);
          }
      
          @ExceptionHandler(DeleteAdminException.class)
          public ResponseEntity<ErrorMessage> handleDeleteAdmin(DeleteAdminException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Can't remove ADMINISTRATOR role!", e.getPath()));
          }
      
          @ExceptionHandler(RoleNotFoundException.class)
          public ResponseEntity<ErrorMessage> handleRoleNotFound() {
              return new ResponseEntity<>(new ErrorMessage(LocalDateTime.now(), HttpStatus.NOT_FOUND, "Not Found", "Role not found!", "/api/admin/user/role"), HttpStatus.NOT_FOUND);
          }
      
          @ExceptionHandler(UserDoesNotHaveRoleException.class)
          public ResponseEntity<ErrorMessage> handleUserDoesNotHaveRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user does not have a role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(DeleteUserOnlyRoleException.class)
          public ResponseEntity<ErrorMessage> handleDeleteUserOnlyRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user must have at least one role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(DeleteAdminRoleException.class)
          public ResponseEntity<ErrorMessage> handleDeleteAdminRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Can't remove ADMINISTRATOR role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(CombineAdminBusinessRoleException.class)
          public ResponseEntity<ErrorMessage> handleCombineAdminBusinessRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user cannot combine administrative and business roles!", "/api/admin/user/role"));
          }
      }
    learner_created: true
  - name: src/account/exceptions/BreachedPasswordException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class BreachedPasswordException extends RuntimeException {
          private final String path;
      
          public BreachedPasswordException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/SamePasswordException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class SamePasswordException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/PasswordUtils.java
    visible: true
    text: |
      package account;
      
      import java.util.Arrays;
      
      public class PasswordUtils {
          public static boolean isPasswordTooShort(String password) {
              return Arrays.stream(password.split("")).filter(s -> !s.isBlank()).count() < 12;
          }
      
          public static boolean isBreachedPassword(String password) {
              return password.matches("PasswordFor((January)|(February)|(March)|(April)|(May)|(June)|(July)|(August)|(September)|(October)|(November)|(December))");
          }
      }
    learner_created: true
  - name: src/account/exceptions/NegativeSalaryException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class NegativeSalaryException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/LockAdminException.java
    visible: true
    learner_created: true
  - name: src/account/security/SecurityConfig.java
    visible: true
    text: |
      package account;
      
      import jakarta.servlet.http.HttpServletResponse;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.http.HttpMethod;
      import org.springframework.security.config.Customizer;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.security.web.SecurityFilterChain;
      
      @Configuration
      public class SecurityConfig {
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              return http
                      .httpBasic(Customizer.withDefaults())
                      .csrf(AbstractHttpConfigurer::disable)
                      .authorizeHttpRequests(auth -> auth
                              .requestMatchers("/api/admin/user/**").hasRole("ADMINISTRATOR")
                              .requestMatchers("/api/acct/payments").hasRole("ACCOUNTANT")
                              .requestMatchers(HttpMethod.POST, "/api/auth/signup", "/actuator/shutdown").permitAll()
                              .requestMatchers(HttpMethod.POST, "/api/auth/changepass").hasAnyRole("ADMINISTRATOR", "ACCOUNTANT", "USER")
                              .requestMatchers(HttpMethod.GET, "/api/empl/payment").hasAnyRole("ACCOUNTANT", "USER")
                              .anyRequest().authenticated()
      
                      ).exceptionHandling(ex -> ex.accessDeniedHandler((request, response, accessDeniedException) -> response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied!")))
                      .build();
          }
      
          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder(13);
          }
      }
    learner_created: true
  - name: src/account/security/SecurityEvent.java
    visible: true
    learner_created: true
  - name: src/account/security/SecurityLog.java
    visible: true
    learner_created: true
  - name: src/account/security/SecurityLogRepository.java
    visible: true
    learner_created: true
  - name: src/account/security/SecurityService.java
    visible: true
    learner_created: true
  - name: src/account/group/Group.java
    visible: true
    text: |
      package account;
      
      import jakarta.persistence.*;
      import lombok.Getter;
      import lombok.NoArgsConstructor;
      import lombok.Setter;
      import lombok.ToString;
      import org.springframework.security.core.GrantedAuthority;
      
      import java.util.LinkedHashSet;
      import java.util.Set;
      
      @Entity
      @Table(name = "groups")
      @Getter
      @Setter
      @NoArgsConstructor
      @ToString(exclude = "usersInGroup")
      public class Group implements GrantedAuthority {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          @Enumerated(value = EnumType.STRING)
          private Role role;
          @ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
          @JoinTable(
                  name = "group_user",
                  joinColumns = @JoinColumn(name = "group_id"),
                  inverseJoinColumns = @JoinColumn(name = "user_id"))
          private Set<AccountUser> usersInGroup = new LinkedHashSet<>();
      
          public Group(Role role) {
              this.role = role;
          }
      
          @Override
          public String getAuthority() {
              return role.name();
          }
      
          public enum Role {
              ADMINISTRATOR, USER, ACCOUNTANT;
          }
      }
    learner_created: true
  - name: src/account/group/GroupLoader.java
    visible: true
    text: |
      package account;
      
      import org.springframework.stereotype.Component;
      
      @Component
      public class DataLoader {
          private final GroupRepository groupRepository;
      
          public DataLoader(GroupRepository groupRepository) {
              this.groupRepository = groupRepository;
      
              if (!groupRepository.isInitialisedWithRoles())
                  initialiseRoles();
          }
      
          private void initialiseRoles() {
              groupRepository.save(new Group(Group.Role.ADMINISTRATOR));
              groupRepository.save(new Group(Group.Role.ACCOUNTANT));
              groupRepository.save(new Group(Group.Role.USER));
          }
      }
    learner_created: true
  - name: src/account/group/GroupRepository.java
    visible: true
    text: |
      package account;
      
      import org.springframework.data.repository.CrudRepository;
      
      import java.util.List;
      
      public interface GroupRepository extends CrudRepository<Group, Long> {
          Group findGroupByRole(Group.Role role);
      
          List<Group> findGroupsByUsersInGroupContains(AccountUser user);
      
          default boolean isInitialisedWithRoles() {
              return getAdminGroup() != null;
          }
      
          default Group getAdminGroup() {
              return findGroupByRole(Group.Role.ADMINISTRATOR);
          }
      
          default Group getAccountantGroup() {
              return findGroupByRole(Group.Role.ACCOUNTANT);
          }
      
          default Group getUserGroup() {
              return findGroupByRole(Group.Role.USER);
          }
      }
    learner_created: true
  - name: src/account/user/AccountUser.java
    visible: true
    text: |
      package account;
      
      import jakarta.persistence.*;
      import jakarta.validation.constraints.Email;
      import jakarta.validation.constraints.NotBlank;
      import jakarta.validation.constraints.NotNull;
      import lombok.Getter;
      import lombok.NoArgsConstructor;
      import lombok.Setter;
      import lombok.ToString;
      
      import java.util.EnumSet;
      import java.util.LinkedHashSet;
      import java.util.Set;
      import java.util.stream.Collectors;
      
      @Entity
      @Table(name = "users")
      @Getter
      @Setter
      @NoArgsConstructor
      @ToString(exclude = "roles")
      public class AccountUser {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          @NotBlank
          private String name;
          @NotBlank
          private String lastname;
          @NotNull
          @Email(regexp = "\\w+@acme.com")
          private String email;
          @NotNull
          private String password;
          @ManyToMany(mappedBy = "usersInGroup", fetch = FetchType.EAGER)
          private Set<Group> roles = new LinkedHashSet<>();
      
          public String[] getRolesAsStrings() {
              return roles.stream().map(Group::getAuthority).collect(Collectors.joining(",")).split(",");
          }
      
          public String[] getFormattedAndSortedRolesAsStrings() {
              return roles.stream().map(r -> "ROLE_" + r.getAuthority()).sorted().collect(Collectors.joining(",")).split(",");
          }
      
          public EnumSet<Group.Role> getRolesAsEnumSet() {
              return EnumSet.copyOf(roles.stream().map(Group::getRole).collect(Collectors.toList()));
          }
      }
    learner_created: true
  - name: src/account/user/UserRepository.java
    visible: true
    text: |
      package account;
      
      import org.springframework.data.domain.Sort;
      import org.springframework.data.repository.CrudRepository;
      import org.springframework.data.repository.ListPagingAndSortingRepository;
      
      import java.util.List;
      import java.util.Optional;
      
      public interface UserRepository extends ListPagingAndSortingRepository<AccountUser, Long>, CrudRepository<AccountUser, Long> {
          default List<AccountUser> getAllUsersWithAscendingIds() {
              return findAll(Sort.by("id"));
          }
      
          Optional<AccountUser> findUserByEmailIgnoreCase(String email);
      }
    learner_created: true
  - name: src/account/security/IncorrectPasswordRecord.java
    visible: true
    learner_created: true
  - name: src/account/security/IncorrectPasswordRecordRepository.java
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/16606#comment
status: Solved
feedback:
  message: Congratulations!
  time: "Fri, 05 Jan 2024 10:27:02 UTC"
record: 6
