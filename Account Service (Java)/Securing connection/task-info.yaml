type: edu
files:
  - name: src/account/AccountServiceApplication.java
    visible: true
    text: |
      package account;
      
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      
      @SpringBootApplication
      public class AccountServiceApplication {
      
          public static void main(String[] args) {
              SpringApplication.run(AccountServiceApplication.class, args);
          }
      
      }
    learner_created: false
  - name: src/resources/application.properties
    visible: true
    text: |-
      server.port=28852
      management.endpoints.web.exposure.include=*
      management.endpoint.shutdown.enabled=true
      spring.jackson.serialization.INDENT_OUTPUT=true
    learner_created: false
  - name: build.gradle
    visible: true
    text: |
      buildscript {
          apply plugin: 'hyperskill'
      
          repositories {
              mavenCentral()
          }
      
          dependencies {
              classpath "org.springframework.boot:spring-boot-gradle-plugin:$hs.spring.bootVersion"
              classpath "io.spring.gradle:dependency-management-plugin:$hs.spring.dependencyManagementVersion"
          }
      }
      
      apply plugin: 'java'
      apply plugin: 'org.springframework.boot'
      apply plugin: 'io.spring.dependency-management'
      
      repositories {
          mavenCentral()
      }
      
      sourceSets.main.resources.srcDirs = ["src/resources"]
      
      dependencies {
          implementation 'org.springframework.boot:spring-boot-starter'
          implementation 'org.springframework.boot:spring-boot-starter-actuator'
          implementation 'org.springframework.boot:spring-boot-starter-web'
          implementation 'com.h2database:h2'
          implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
      }
      
      test {
          jvmArgs '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
      }
    learner_created: false
  - name: test/AccountServiceTest.java
    visible: false
    text: |
      import account.AccountServiceApplication;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.dynamic.input.DynamicTesting;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.mocks.web.request.HttpRequest;
      import org.hyperskill.hstest.stage.SpringTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import javax.net.ssl.*;
      import java.security.cert.X509Certificate;
      
      public class AccountServiceTest extends SpringTest {
        public AccountServiceTest() {
          super(AccountServiceApplication.class, "../service_db.mv.db");
        }
      
        SSLSocket socket;
        java.security.cert.X509Certificate[] chain;
      
        // Warning!!! Only for testing reason, trust all certificates!
        TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                  public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return new java.security.cert.X509Certificate[0];
                  }
                  public void checkClientTrusted(
                          java.security.cert.X509Certificate[] certs, String authType) {
                  }
                  public void checkServerTrusted(
                          java.security.cert.X509Certificate[] certs, String authType) {
                  }
                }
        };
      
        // Test SSL
        public CheckResult checkCertificateName(String nameCN) {
          try {
            SSLContext sc = SSLContext.getInstance("SSL");
            //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            SSLSocketFactory factory = sc.getSocketFactory();
            HttpRequest request = get("");
            socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
            getCertificates();
            if (findCert(nameCN)) {
              return CheckResult.correct();
            } else {
              throw new WrongAnswer("Not found certificate with CN - " + nameCN);
            }
          } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Connection not found");
            throw new WrongAnswer("Can't establish https connection!");
          }
        }
      
        // Get certificate chain
        public void getCertificates() {
          try {
            chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
          } catch (SSLPeerUnverifiedException e) {
            e.printStackTrace();
            System.out.println(e.toString());
          }
        }
      
      
        // Searching certificate by Common Name
        public boolean findCert(String subject) {
          for (java.security.cert.X509Certificate c : chain) {
            String subjectName = c.getSubjectDN().getName();
            System.out.println(subjectName + " " + c.getSigAlgName());
            if (subjectName.contains("CN=" + subject)) {
              return true;
            }
          }
          return false;
        }
      
        @DynamicTest
        DynamicTesting[] dt = new DynamicTesting[]{
      
                // Check certificate name
                () -> checkCertificateName("accountant_service"),
        };
      }
    learner_created: false
  - name: src/account/AccountService.java
    visible: true
    text: |
      package account;
      
      import account.exceptions.*;
      import account.group.Group;
      import account.group.GroupRepository;
      import account.payroll.Payroll;
      import account.payroll.PayrollID;
      import account.payroll.PayrollRepository;
      import account.security.SecurityEvent;
      import account.user.AccountUser;
      import account.user.UserRepository;
      import org.springframework.context.ApplicationEventPublisher;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.stereotype.Service;
      import org.springframework.transaction.annotation.Transactional;
      
      import java.time.LocalDate;
      import java.util.List;
      import java.util.Optional;
      
      @Service
      public class AccountService {
          private final UserRepository userRepository;
          private final PayrollRepository payrollRepository;
          private final GroupRepository groupRepository;
          private final PasswordEncoder passwordEncoder;
      
          private final ApplicationEventPublisher eventPublisher;
      
          public AccountService(UserRepository userRepository, PayrollRepository payrollRepository, GroupRepository groupRepository, PasswordEncoder passwordEncoder, ApplicationEventPublisher eventPublisher) {
              this.userRepository = userRepository;
              this.payrollRepository = payrollRepository;
              this.groupRepository = groupRepository;
              this.passwordEncoder = passwordEncoder;
              this.eventPublisher = eventPublisher;
          }
      
          public AccountUser getUserFromEmail(String email) {
              return userRepository.findUserByEmailIgnoreCase(email).orElse(null);
          }
      
          public AccountUser addUser(AccountUser user, String auth) {
              if (userRepository.findUserByEmailIgnoreCase(user.getEmail()).isPresent()) {
                  throw new UserAlreadyExistsException();
              }
      
              user.setEmail(user.getEmail().toLowerCase());
              user.setPassword(passwordEncoder.encode(user.getPassword()));
      
              boolean isAdministratorAlreadyAdded = groupRepository.getAdminGroup().getUsersInGroup().size() == 1;
      
              if (isAdministratorAlreadyAdded) {
                  Group users = groupRepository.getUserGroup();
                  users.getUsersInGroup().add(user);
                  user.getRoles().add(users);
                  groupRepository.save(users);
              } else {
                  Group admin = groupRepository.getAdminGroup();
                  admin.getUsersInGroup().add(user);
                  user.getRoles().add(admin);
                  groupRepository.save(admin);
              }
      
              eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.CREATE_USER, auth == null ? "Anonymous" : auth, user.getEmail(), "/api/auth/signup"));
      
              return getUserFromEmail(user.getEmail());
          }
      
          public void changeUserPassword(String email, String newPassword) {
              AccountUser user = getUserFromEmail(email);
      
              if (passwordEncoder.matches(newPassword, user.getPassword())) {
                  throw new SamePasswordException();
              }
      
              user.setPassword(passwordEncoder.encode(newPassword));
              userRepository.save(user);
      
              eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.CHANGE_PASSWORD, email, email, "/api/auth/changepass"));
          }
      
          @Transactional
          public void addPayrolls(List<Payroll> payrolls) {
              payrolls.forEach(payroll -> {
                  if (payroll.getSalary() < 0) {
                      throw new NegativeSalaryException();
                  }
      
                  if (getUserFromEmail(payroll.getEmployee()) == null) {
                      throw new UserDoesNotExistException();
                  }
      
                  payroll.setEmployee(payroll.getEmployee().toLowerCase());
      
                  if (payrollRepository.existsById(new PayrollID(payroll.getEmployee(), payroll.getPeriod()))) {
                      throw new PayrollAlreadyExistsException();
                  }
      
                  payrollRepository.save(payroll);
              });
          }
      
          public void updatePayroll(Payroll payroll) {
              if (payroll.getSalary() < 0) {
                  throw new NegativeSalaryException();
              }
      
              if (getUserFromEmail(payroll.getEmployee()) == null) {
                  throw new UserDoesNotExistException();
              }
      
              Payroll updatedPayroll = payrollRepository.findById(new PayrollID(payroll.getEmployee().toLowerCase(), payroll.getPeriod())).get();
      
              updatedPayroll.setSalary(payroll.getSalary());
              payrollRepository.save(updatedPayroll);
          }
      
      
          public Optional<Payroll> getPayrollForUser(String email, LocalDate period) {
              return payrollRepository.findById(new PayrollID(email, period));
          }
      
          public List<Payroll> getAllPayrollsForUser(String email) {
              return payrollRepository.getPayrollsByEmployeeIgnoreCaseOrderByPeriodDesc(email);
          }
      
          public List<AccountUser> getUsers() {
              return userRepository.getAllUsersWithAscendingIds();
          }
      
          public void deleteUser(String email, String auth) {
              AccountUser user = getUserFromEmail(email);
      
              if (user.getRoles().contains(groupRepository.getAdminGroup())) {
                  throw new DeleteAdminException("/api/admin/user/" + email);
              }
      
              List<Group> groups = groupRepository.findGroupsByUsersInGroupContains(user);
      
              groups.forEach(g -> {
                  g.getUsersInGroup().remove(user);
                  user.getRoles().remove(g);
                  groupRepository.save(g);
              });
      
              userRepository.delete(user);
      
              eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.DELETE_USER, auth, email, "/api/admin/user/"));
          }
      
          public AccountUser changeUserRole(String email, Group.Role role, String operation, String auth) {
              AccountUser user = getUserFromEmail(email);
      
              if (user == null) {
                  throw new UserNotFoundException("/api/admin/user/role");
              }
      
              Group group = switch (role) {
                  case ADMINISTRATOR -> groupRepository.getAdminGroup();
                  case USER -> groupRepository.getUserGroup();
                  case ACCOUNTANT -> groupRepository.getAccountantGroup();
                  case AUDITOR -> groupRepository.getAuditorGroup();
              };
      
              if (operation.equals("GRANT")) {
                  if (user.isAdmin() && (role == Group.Role.ACCOUNTANT || role == Group.Role.USER || role == Group.Role.AUDITOR)) {
                      throw new CombineAdminBusinessRoleException();
                  } else if (!user.isAdmin() && role == Group.Role.ADMINISTRATOR) {
                      throw new CombineAdminBusinessRoleException();
                  }
      
                  group.getUsersInGroup().add(user);
                  user.getRoles().add(group);
      
                  eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.GRANT_ROLE, auth, "Grant role " + role.name() + " to " + email.toLowerCase(), "/api/admin/user/role"));
              } else {
                  if (!user.getRolesAsEnumSet().contains(role)) {
                      throw new UserDoesNotHaveRoleException();
                  }
      
                  if (user.isAdmin()) {
                      throw new DeleteAdminRoleException();
                  }
      
                  if (user.getRoles().size() == 1) {
                      throw new DeleteUserOnlyRoleException();
                  }
      
                  group.getUsersInGroup().remove(user);
                  user.getRoles().remove(group);
      
                  eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.REMOVE_ROLE, auth, "Remove role " + role.name() + " from " + email.toLowerCase(), "/api/admin/user/role"));
              }
      
              groupRepository.save(group);
      
              return user;
          }
      }
    learner_created: true
  - name: src/account/security/SecurityEvent.java
    visible: true
    text: |
      package account.security;
      
      import lombok.Getter;
      import lombok.Setter;
      import org.springframework.context.ApplicationEvent;
      
      import java.time.LocalDate;
      
      @Getter
      @Setter
      public class SecurityEvent extends ApplicationEvent {
          private LocalDate date;
          private Action action;
          private String subject;
          private String object;
          private String path;
      
          public SecurityEvent(Object source, LocalDate date, Action action, String subject, String object, String path) {
              super(source);
              this.date = date;
              this.action = action;
              this.subject = subject;
              this.object = object;
              this.path = path;
          }
      
          public SecurityLog generateLog() {
              return new SecurityLog(date, action.name(), subject, object, path);
          }
      
          public enum Action {
              CREATE_USER, CHANGE_PASSWORD, ACCESS_DENIED, LOGIN_FAILED, GRANT_ROLE, REMOVE_ROLE, LOCK_USER, UNLOCK_USER, DELETE_USER, BRUTE_FORCE
          }
      }
    learner_created: true
  - name: src/account/exceptions/UserAlreadyExistsException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserAlreadyExistsException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/RoleNotFoundException.java
    visible: true
    text: |-
      package account.exceptions;
      
      public class RoleNotFoundException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/user/UserRepository.java
    visible: true
    text: |
      package account.user;
      
      import org.springframework.data.domain.Sort;
      import org.springframework.data.repository.CrudRepository;
      import org.springframework.data.repository.ListPagingAndSortingRepository;
      
      import java.util.List;
      import java.util.Optional;
      
      public interface UserRepository extends ListPagingAndSortingRepository<AccountUser, Long>, CrudRepository<AccountUser, Long> {
          default List<AccountUser> getAllUsersWithAscendingIds() {
              return findAll(Sort.by("id"));
          }
      
          Optional<AccountUser> findUserByEmailIgnoreCase(String email);
      }
    learner_created: true
  - name: src/account/security/IncorrectPasswordRecord.java
    visible: true
    text: |
      package account.security;
      
      import jakarta.persistence.*;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      @Entity
      @Table(name = "incorrect_password_records")
      @Data
      @NoArgsConstructor
      public class IncorrectPasswordRecord {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          private String username;
          private int count;
      
          public IncorrectPasswordRecord(String username, int count) {
              this.username = username;
              this.count = count;
          }
      }
    learner_created: true
  - name: src/account/exceptions/DeleteUserOnlyRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class DeleteUserOnlyRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/PayrollAlreadyExistsException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class PayrollAlreadyExistsException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/UserDoesNotHaveRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserDoesNotHaveRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/PasswordTooShortException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class PasswordTooShortException extends RuntimeException {
          private final String path;
      
          public PasswordTooShortException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/ErrorMessage.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Data;
      import org.springframework.http.HttpStatus;
      
      import java.time.LocalDateTime;
      
      @Data
      public class ErrorMessage {
          public ErrorMessage(LocalDateTime timestamp, HttpStatus status, String error, String message, String path) {
              this.timestamp = timestamp;
              this.status = status.value();
              this.error = error;
              this.message = message;
              this.path = path;
          }
      
          private LocalDateTime timestamp;
          private int status;
          private String error;
          private String message;
          private String path;
      }
    learner_created: true
  - name: src/account/payroll/Payroll.java
    visible: true
    text: |
      package account.payroll;
      
      import com.fasterxml.jackson.annotation.JsonCreator;
      import com.fasterxml.jackson.annotation.JsonProperty;
      import jakarta.persistence.Entity;
      import jakarta.persistence.Id;
      import jakarta.persistence.IdClass;
      import jakarta.persistence.Table;
      import jakarta.validation.constraints.NotNull;
      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      import java.time.LocalDate;
      
      @Entity
      @Table(name = "payrolls")
      @IdClass(PayrollID.class)
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class Payroll {
          @Id
          @NotNull
          private String employee;
          @Id
          @NotNull
          private LocalDate period;
          @NotNull
          private long salary;
      
          @JsonCreator
          public Payroll(@JsonProperty("employee") String employee, @JsonProperty("period") String period, @JsonProperty("salary") long salary) {
              this.employee = employee;
              String[] periodParts = period.split("-");
              int month = Integer.parseInt(periodParts[0]);
              int year = Integer.parseInt(periodParts[1]);
              this.period = LocalDate.of(year, month, 1);
              this.salary = salary;
          }
      }
    learner_created: true
  - name: src/account/security/SecurityService.java
    visible: true
    text: |
      package account.security;
      
      import account.user.AccountUser;
      import account.user.UserRepository;
      import org.springframework.context.event.EventListener;
      import org.springframework.data.domain.Sort;
      import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
      import org.springframework.stereotype.Service;
      
      import java.time.LocalDate;
      import java.util.List;
      import java.util.Optional;
      
      @Service
      public class SecurityService {
          private final SecurityLogRepository securityLogRepository;
          private final IncorrectPasswordRecordRepository incorrectPasswordRecordRepository;
          private final UserRepository userRepository;
      
          public SecurityService(SecurityLogRepository repository, IncorrectPasswordRecordRepository incorrectPasswordRecordRepository, UserRepository userRepository) {
              this.securityLogRepository = repository;
              this.incorrectPasswordRecordRepository = incorrectPasswordRecordRepository;
              this.userRepository = userRepository;
          }
      
          public List<SecurityLog> getSecurityLogs() {
              return securityLogRepository.findAll(Sort.by("id"));
          }
      
          @EventListener(SecurityEvent.class)
          public void logSecurityEvent(SecurityEvent event) {
              securityLogRepository.save(event.generateLog());
      
              if (event.getAction() == SecurityEvent.Action.LOGIN_FAILED) {
                  logIncorrectPasswordAttempt(event);
              }
          }
      
          public void logIncorrectPasswordAttempt(SecurityEvent event) {
              Optional<AccountUser> user = userRepository.findUserByEmailIgnoreCase(event.getSubject());
              if (user.isPresent()) {
                  IncorrectPasswordRecord record = incorrectPasswordRecordRepository.findByUsernameIgnoreCase(user.get().getEmail());
      
                  if (record == null) {
                      record = new IncorrectPasswordRecord(user.get().getEmail(), 1);
                  } else {
                      record.setCount(record.getCount() + 1);
      
                      if (record.getCount() == 5) {
                          securityLogRepository.save(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.BRUTE_FORCE, event.getSubject(), event.getPath(), event.getPath()).generateLog());
                          lockOrUnlockUser(user.get(), true, event.getSubject(), event.getPath());
                      }
                  }
      
                  incorrectPasswordRecordRepository.save(record);
              }
          }
      
          @EventListener(AuthenticationSuccessEvent.class)
          public void resetIncorrectPasswordAttempts(AuthenticationSuccessEvent event) {
              AccountUser user = userRepository.findUserByEmailIgnoreCase(event.getAuthentication().getName()).get();
              IncorrectPasswordRecord record = incorrectPasswordRecordRepository.findByUsernameIgnoreCase(user.getEmail());
      
              if (record != null) {
                  record.setCount(0);
                  incorrectPasswordRecordRepository.save(record);
              }
          }
      
          public void lockOrUnlockUser(AccountUser user, boolean locked, String auth, String path) {
              SecurityEvent.Action action = locked ? SecurityEvent.Action.LOCK_USER : SecurityEvent.Action.UNLOCK_USER;
              user.setLocked(locked);
              userRepository.save(user);
      
              logSecurityEvent(new SecurityEvent(this, LocalDate.now(), action, auth, (locked ? "Lock" : "Unlock") + " user " + user.getEmail(), path));
          }
      }
    learner_created: true
  - name: src/account/security/SecurityLogRepository.java
    visible: true
    text: |
      package account.security;
      
      import org.springframework.data.repository.CrudRepository;
      import org.springframework.data.repository.ListPagingAndSortingRepository;
      
      public interface SecurityLogRepository extends ListPagingAndSortingRepository<SecurityLog, Long>, CrudRepository<SecurityLog, Long> {
      }
    learner_created: true
  - name: src/account/exceptions/DeleteAdminRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class DeleteAdminRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/AccountRestController.java
    visible: true
    text: |
      package account;
      
      import account.exceptions.*;
      import account.group.Group;
      import account.payroll.Payroll;
      import account.security.SecurityLog;
      import account.security.SecurityService;
      import account.user.AccountUser;
      import jakarta.validation.Valid;
      import jakarta.validation.constraints.NotNull;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.http.converter.HttpMessageConversionException;
      import org.springframework.security.core.Authentication;
      import org.springframework.web.bind.annotation.*;
      
      import java.time.LocalDate;
      import java.time.LocalDateTime;
      import java.time.format.TextStyle;
      import java.util.List;
      import java.util.Locale;
      
      @RestController
      public class AccountRestController {
          private final AccountService accountService;
          private final SecurityService securityService;
      
          public AccountRestController(AccountService accountService, SecurityService securityService) {
              this.accountService = accountService;
              this.securityService = securityService;
          }
      
      
          @PostMapping("api/auth/signup")
          public ResponseEntity<UserResponse> signupUser(@Valid @RequestBody AccountUser user, Authentication auth) {
              if (PasswordUtils.isPasswordTooShort(user.getPassword())) {
                  throw new PasswordTooShortException("/api/auth/signup");
              }
      
              if (PasswordUtils.isBreachedPassword(user.getPassword())) {
                  throw new BreachedPasswordException("/api/auth/signup");
              }
      
              user = accountService.addUser(user, auth == null ? null : auth.getName());
      
              return ResponseEntity.ok(formatUserAsResponse(user));
          }
      
          @PostMapping("api/auth/changepass")
          public ResponseEntity<UpdatedPasswordResponse> changePassword(@Valid @RequestBody ChangePasswordRequest request, Authentication auth) {
              if (PasswordUtils.isPasswordTooShort(request.new_password)) {
                  throw new PasswordTooShortException("/api/auth/changepass");
              }
      
              if (PasswordUtils.isBreachedPassword(request.new_password)) {
                  throw new BreachedPasswordException("/api/auth/changepass");
              }
      
              accountService.changeUserPassword(auth.getName(), request.new_password);
      
              return ResponseEntity.ok(new UpdatedPasswordResponse(auth.getName(), "The password has been updated successfully"));
          }
      
      
          @PostMapping("api/acct/payments")
          public ResponseEntity<StatusResponse> uploadPayrolls(@RequestBody List<Payroll> payrolls) {
              accountService.addPayrolls(payrolls);
      
              return ResponseEntity.ok(new StatusResponse("Added successfully!"));
          }
      
          @PutMapping("api/acct/payments")
          public ResponseEntity<StatusResponse> updatePayroll(@RequestBody Payroll payroll) {
              accountService.updatePayroll(payroll);
      
              return ResponseEntity.ok(new StatusResponse("Updated successfully!"));
          }
      
          @ExceptionHandler(HttpMessageConversionException.class)
          public ResponseEntity<ErrorMessage> handleInvalidPeriod(HttpMessageConversionException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Period month is invalid!", "/api/acct/payments"));
          }
      
      
          @GetMapping("api/empl/payment")
          public ResponseEntity<Object> getPayrolls(@RequestParam(required = false, name = "period") String periodString, Authentication auth) {
              if (periodString == null) {
                  return ResponseEntity.ok(accountService.getAllPayrollsForUser(auth.getName()).stream().map(this::formatPayrollAsResponse).toList());
              } else {
                  String[] periodParts = periodString.split("-");
                  int month = Integer.parseInt(periodParts[0]);
                  int year = Integer.parseInt(periodParts[1]);
      
                  if (month < 1 || month > 12) {
                      throw new InvalidPeriodException();
                  }
      
                  return ResponseEntity.ok(formatPayrollAsResponse(accountService.getPayrollForUser(auth.getName(), LocalDate.of(year, month, 1)).orElse(null)));
              }
          }
      
          @GetMapping("api/admin/user/")
          public ResponseEntity<List<UserResponse>> getUsers() {
              return ResponseEntity.ok(accountService.getUsers().stream().map(this::formatUserAsResponse).toList());
          }
      
          @DeleteMapping("api/admin/user/{email}")
          public ResponseEntity<DeletedUserResponse> deleteUser(@PathVariable String email, Authentication auth) {
              if (accountService.getUserFromEmail(email) == null) {
                  throw new UserNotFoundException("/api/admin/user/" + email);
              }
      
              accountService.deleteUser(email, auth.getName());
      
              return ResponseEntity.ok(new DeletedUserResponse(email, "Deleted successfully!"));
      
          }
      
          @PutMapping("api/admin/user/role")
          public ResponseEntity<UserResponse> changeRoles(@RequestBody ChangeRoleRequest request, Authentication auth) {
              if (!request.role.matches("(ADMINISTRATOR)|(ACCOUNTANT)|(USER)|(AUDITOR)")) {
                  throw new RoleNotFoundException();
              }
      
              Group.Role role = switch (request.role) {
                  case "ADMINISTRATOR" -> Group.Role.ADMINISTRATOR;
                  case "ACCOUNTANT" -> Group.Role.ACCOUNTANT;
                  case "AUDITOR" -> Group.Role.AUDITOR;
                  default -> Group.Role.USER;
              };
      
              return ResponseEntity.ok(formatUserAsResponse(accountService.changeUserRole(request.user, role, request.operation, auth.getName())));
          }
      
          @PutMapping("api/admin/user/access")
          public ResponseEntity<StatusResponse> lockOrUnlockUser(@Valid @RequestBody LockOrUnlockUserRequest request, Authentication auth) {
              AccountUser user = accountService.getUserFromEmail(request.user);
      
              if (request.operation.equals("LOCK") && user.isAdmin()) {
                  throw new LockAdminException();
              }
      
              securityService.lockOrUnlockUser(user, request.operation.equals("LOCK"), auth.getName(), "/api/admin/user/access");
      
              return ResponseEntity.ok(new StatusResponse("User " + request.user.toLowerCase() + " " + (request.operation.equals("LOCK") ? "locked" : "unlocked") + "!"));
          }
      
          @GetMapping("api/security/events/")
          public ResponseEntity<List<SecurityLog>> getSecurityEvents() {
              return ResponseEntity.ok(securityService.getSecurityLogs());
          }
      
          public UserResponse formatUserAsResponse(AccountUser user) {
              return new UserResponse(user.getId(), user.getName(), user.getLastname(), user.getEmail(), user.getFormattedAndSortedRolesAsStrings());
          }
      
          public PayrollResponse formatPayrollAsResponse(Payroll payroll) {
              if (payroll == null) {
                  return null;
              }
      
              String period = payroll.getPeriod().getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH) + "-" + payroll.getPeriod().getYear();
              long dollars = payroll.getSalary() / 100;
              long cents = payroll.getSalary() % 100;
              String salary = dollars + " dollar(s) " + cents + " cent(s)";
              AccountUser user = accountService.getUserFromEmail(payroll.getEmployee());
              return new PayrollResponse(user.getName(), user.getLastname(), period, salary);
          }
      
          public record UserResponse(long id, String name, String lastname, String email, String[] roles) {
          }
      
          public record ChangePasswordRequest(@NotNull String new_password) {
          }
      
          public record UpdatedPasswordResponse(String email, String status) {
          }
      
          public record StatusResponse(String status) {
          }
      
          public record PayrollResponse(String name, String lastname, String period, String salary) {
          }
      
          public record DeletedUserResponse(String user, String status) {
          }
      
          public record ChangeRoleRequest(String user, String role, String operation) {
          }
      
          public record LockOrUnlockUserRequest(String user, String operation) {
          }
      }
    learner_created: true
  - name: src/account/exceptions/DeleteAdminException.java
    visible: true
    text: |-
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class DeleteAdminException extends RuntimeException {
          private final String path;
      
          public DeleteAdminException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/UserNotFoundException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class UserNotFoundException extends RuntimeException {
          private final String path;
      
          public UserNotFoundException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/InvalidPeriodException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class InvalidPeriodException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/group/GroupRepository.java
    visible: true
    text: |
      package account.group;
      
      import account.user.AccountUser;
      import org.springframework.data.repository.CrudRepository;
      
      import java.util.List;
      
      public interface GroupRepository extends CrudRepository<Group, Long> {
          Group findGroupByRole(Group.Role role);
      
          List<Group> findGroupsByUsersInGroupContains(AccountUser user);
      
          default boolean isInitialisedWithRoles() {
              return getAdminGroup() != null;
          }
      
          default Group getAdminGroup() {
              return findGroupByRole(Group.Role.ADMINISTRATOR);
          }
      
          default Group getAccountantGroup() {
              return findGroupByRole(Group.Role.ACCOUNTANT);
          }
      
          default Group getUserGroup() {
              return findGroupByRole(Group.Role.USER);
          }
      
          default Group getAuditorGroup() {
              return findGroupByRole(Group.Role.AUDITOR);
          }
      }
    learner_created: true
  - name: src/account/exceptions/UserDoesNotExistException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class UserDoesNotExistException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/payroll/PayrollRepository.java
    visible: true
    text: |
      package account.payroll;
      
      import org.springframework.data.repository.CrudRepository;
      
      import java.util.List;
      
      public interface PayrollRepository extends CrudRepository<Payroll, PayrollID> {
          List<Payroll> getPayrollsByEmployeeIgnoreCaseOrderByPeriodDesc(String employee);
      
          List<Payroll> getAllByEmployee(String employee);
      }
    learner_created: true
  - name: src/account/payroll/PayrollID.java
    visible: true
    text: |
      package account.payroll;
      
      import lombok.AllArgsConstructor;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      import java.io.Serializable;
      import java.time.LocalDate;
      
      @Data
      @AllArgsConstructor
      @NoArgsConstructor
      public class PayrollID implements Serializable {
          private String employee;
          private LocalDate period;
      }
    learner_created: true
  - name: src/account/exceptions/CombineAdminBusinessRoleException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class CombineAdminBusinessRoleException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/exceptions/AccountExceptionHandler.java
    visible: true
    text: |
      package account.exceptions;
      
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.ControllerAdvice;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
      
      import java.time.LocalDateTime;
      
      @ControllerAdvice
      public class AccountExceptionHandler extends ResponseEntityExceptionHandler {
          @ExceptionHandler(UserAlreadyExistsException.class)
          public ResponseEntity<ErrorMessage> handleUserAlreadyExists() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "User exist!", "/api/auth/signup"));
          }
      
          @ExceptionHandler(PasswordTooShortException.class)
          public ResponseEntity<ErrorMessage> handlePasswordTooShort(PasswordTooShortException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Password length must be 12 chars minimum!", e.getPath()));
          }
      
          @ExceptionHandler(BreachedPasswordException.class)
          public ResponseEntity<ErrorMessage> handleBreachedPassword(BreachedPasswordException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The password is in the hacker's database!", e.getPath()));
          }
      
          @ExceptionHandler(SamePasswordException.class)
          public ResponseEntity<ErrorMessage> handleSamePassword() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The passwords must be different!", "/api/auth/changepass"));
          }
      
          @ExceptionHandler(NegativeSalaryException.class)
          public ResponseEntity<ErrorMessage> handleNegativeSalary() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Salary cannot be negative for a payroll period!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(UserDoesNotExistException.class)
          public ResponseEntity<ErrorMessage> handleUserDoesNotExist() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Pay roll user does not exist!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(PayrollAlreadyExistsException.class)
          public ResponseEntity<ErrorMessage> handlePayrollAlreadyExists() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Payroll exist!", "/api/acct/payments"));
          }
      
          @ExceptionHandler(InvalidPeriodException.class)
          public ResponseEntity<ErrorMessage> handleInvalidPeriod() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Period month is invalid!", "/api/empl/payment"));
          }
      
          @ExceptionHandler(UserNotFoundException.class)
          public ResponseEntity<ErrorMessage> handleUserNotFound(UserNotFoundException e) {
              return new ResponseEntity<>(new ErrorMessage(LocalDateTime.now(), HttpStatus.NOT_FOUND, "Not Found", "User not found!", e.getPath()), HttpStatus.NOT_FOUND);
          }
      
          @ExceptionHandler(DeleteAdminException.class)
          public ResponseEntity<ErrorMessage> handleDeleteAdmin(DeleteAdminException e) {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Can't remove ADMINISTRATOR role!", e.getPath()));
          }
      
          @ExceptionHandler(RoleNotFoundException.class)
          public ResponseEntity<ErrorMessage> handleRoleNotFound() {
              return new ResponseEntity<>(new ErrorMessage(LocalDateTime.now(), HttpStatus.NOT_FOUND, "Not Found", "Role not found!", "/api/admin/user/role"), HttpStatus.NOT_FOUND);
          }
      
          @ExceptionHandler(UserDoesNotHaveRoleException.class)
          public ResponseEntity<ErrorMessage> handleUserDoesNotHaveRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user does not have a role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(DeleteUserOnlyRoleException.class)
          public ResponseEntity<ErrorMessage> handleDeleteUserOnlyRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user must have at least one role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(DeleteAdminRoleException.class)
          public ResponseEntity<ErrorMessage> handleDeleteAdminRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Can't remove ADMINISTRATOR role!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(CombineAdminBusinessRoleException.class)
          public ResponseEntity<ErrorMessage> handleCombineAdminBusinessRole() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "The user cannot combine administrative and business roles!", "/api/admin/user/role"));
          }
      
          @ExceptionHandler(LockAdminException.class)
          public ResponseEntity<ErrorMessage> handleLockAdmin() {
              return ResponseEntity.badRequest().body(new ErrorMessage(LocalDateTime.now(), HttpStatus.BAD_REQUEST, "Bad Request", "Can't lock the ADMINISTRATOR!", "/api/admin/user/access"));
          }
      }
    learner_created: true
  - name: src/account/security/SecurityConfig.java
    visible: true
    text: |
      package account.security;
      
      import account.user.AccountUser;
      import account.user.UserRepository;
      import com.fasterxml.jackson.databind.ObjectMapper;
      import jakarta.servlet.ServletException;
      import jakarta.servlet.http.HttpServletRequest;
      import jakarta.servlet.http.HttpServletResponse;
      import org.springframework.context.ApplicationEventPublisher;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.http.HttpHeaders;
      import org.springframework.http.HttpMethod;
      import org.springframework.http.MediaType;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
      import org.springframework.security.core.AuthenticationException;
      import org.springframework.security.core.userdetails.User;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.core.userdetails.UsernameNotFoundException;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.security.web.AuthenticationEntryPoint;
      import org.springframework.security.web.SecurityFilterChain;
      
      import java.io.IOException;
      import java.nio.charset.StandardCharsets;
      import java.time.LocalDate;
      import java.util.Base64;
      import java.util.HashMap;
      import java.util.Map;
      
      @Configuration
      public class SecurityConfig {
          private final UserRepository repository;
          private final ApplicationEventPublisher eventPublisher;
      
          public SecurityConfig(UserRepository repository, ApplicationEventPublisher eventPublisher) {
              this.repository = repository;
              this.eventPublisher = eventPublisher;
          }
      
          @Bean
          public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
              return http
                      .httpBasic(auth -> auth.authenticationEntryPoint(new AuthenticationEntryPoint() {
                          @Override
                          public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
                              if (request.getHeader(HttpHeaders.AUTHORIZATION) != null) {
                                  String user = new String(Base64.getDecoder().decode(request.getHeader(HttpHeaders.AUTHORIZATION).split(" ")[1]), StandardCharsets.UTF_8).split(":")[0];
      
                                  boolean isUserLocked = repository.findUserByEmailIgnoreCase(user).isPresent() && repository.findUserByEmailIgnoreCase(user).get().isLocked();
                                  if (!isUserLocked) {
                                      eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.LOGIN_FAILED, user, request.getServletPath(), request.getServletPath()));
                                  }
                              }
      
                              response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                              response.setContentType(MediaType.APPLICATION_JSON_VALUE);
      
                              final Map<String, Object> body = new HashMap<>();
                              body.put("error", "Unauthorized");
                              body.put("path", request.getServletPath());
                              body.put("status", response.getStatus());
                              body.put("message", "User account is locked");
                              new ObjectMapper().writeValue(response.getOutputStream(), body);
                          }
                      }))
                      .csrf(AbstractHttpConfigurer::disable)
                      .authorizeHttpRequests(auth -> auth
                              .requestMatchers(HttpMethod.GET, "/api/security/events/").hasRole("AUDITOR")
                              .requestMatchers("/api/admin/user/**").hasRole("ADMINISTRATOR")
                              .requestMatchers("/api/acct/payments").hasRole("ACCOUNTANT")
                              .requestMatchers(HttpMethod.POST, "/api/auth/signup", "/actuator/shutdown").permitAll()
                              .requestMatchers(HttpMethod.POST, "/api/auth/changepass").hasAnyRole("ADMINISTRATOR", "ACCOUNTANT", "USER")
                              .requestMatchers(HttpMethod.GET, "/api/empl/payment").hasAnyRole("ACCOUNTANT", "USER")
                              .anyRequest().authenticated()
                      )
                      .exceptionHandling(ex -> ex.accessDeniedHandler((request, response, accessDeniedException) -> {
                          eventPublisher.publishEvent(new SecurityEvent(this, LocalDate.now(), SecurityEvent.Action.ACCESS_DENIED, request.getUserPrincipal().getName(), request.getRequestURI(), request.getRequestURI()));
                          response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied!");
                      }))
                      .build();
          }
      
          @Bean
          public UserDetailsService userDetailsService() {
              return username -> {
                  AccountUser user = repository.findUserByEmailIgnoreCase(username).orElseThrow(() -> new UsernameNotFoundException("User not found"));
      
                  return User.withUsername(user.getEmail()).password(user.getPassword()).roles(user.getRolesAsStrings()).disabled(user.isLocked() && !user.isAdmin()).build();
              };
          }
      
          @Bean
          public PasswordEncoder passwordEncoder() {
              return new BCryptPasswordEncoder(13);
          }
      }
    learner_created: true
  - name: src/account/exceptions/LockAdminException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class LockAdminException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/group/Group.java
    visible: true
    text: |
      package account.group;
      
      import account.user.AccountUser;
      import jakarta.persistence.*;
      import lombok.Getter;
      import lombok.NoArgsConstructor;
      import lombok.Setter;
      import lombok.ToString;
      import org.springframework.security.core.GrantedAuthority;
      
      import java.util.LinkedHashSet;
      import java.util.Set;
      
      @Entity
      @Table(name = "groups")
      @Getter
      @Setter
      @NoArgsConstructor
      @ToString(exclude = "usersInGroup")
      public class Group implements GrantedAuthority {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          @Enumerated(value = EnumType.STRING)
          private Role role;
          @ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
          @JoinTable(
                  name = "group_user",
                  joinColumns = @JoinColumn(name = "group_id"),
                  inverseJoinColumns = @JoinColumn(name = "user_id"))
          private Set<AccountUser> usersInGroup = new LinkedHashSet<>();
      
          public Group(Role role) {
              this.role = role;
          }
      
          @Override
          public String getAuthority() {
              return role.name();
          }
      
          public enum Role {
              ADMINISTRATOR, USER, ACCOUNTANT, AUDITOR;
          }
      }
    learner_created: true
  - name: src/account/exceptions/BreachedPasswordException.java
    visible: true
    text: |
      package account.exceptions;
      
      import lombok.Getter;
      
      @Getter
      public class BreachedPasswordException extends RuntimeException {
          private final String path;
      
          public BreachedPasswordException(String path) {
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/exceptions/SamePasswordException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class SamePasswordException extends RuntimeException {
      }
    learner_created: true
  - name: src/account/user/AccountUser.java
    visible: true
    text: |
      package account.user;
      
      import account.group.Group;
      import jakarta.persistence.*;
      import jakarta.validation.constraints.Email;
      import jakarta.validation.constraints.NotBlank;
      import jakarta.validation.constraints.NotNull;
      import lombok.Getter;
      import lombok.NoArgsConstructor;
      import lombok.Setter;
      import lombok.ToString;
      
      import java.util.EnumSet;
      import java.util.LinkedHashSet;
      import java.util.Set;
      import java.util.stream.Collectors;
      
      @Entity
      @Table(name = "users")
      @Getter
      @Setter
      @NoArgsConstructor
      @ToString(exclude = "roles")
      public class AccountUser {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          @NotBlank
          private String name;
          @NotBlank
          private String lastname;
          @NotNull
          @Email(regexp = "\\w+@acme.com")
          private String email;
          @NotNull
          private String password;
          @ManyToMany(mappedBy = "usersInGroup", fetch = FetchType.EAGER)
          private Set<Group> roles = new LinkedHashSet<>();
          private boolean isLocked;
      
          public String[] getRolesAsStrings() {
              return roles.stream().map(Group::getAuthority).collect(Collectors.joining(",")).split(",");
          }
      
          public String[] getFormattedAndSortedRolesAsStrings() {
              return roles.stream().map(r -> "ROLE_" + r.getAuthority()).sorted().collect(Collectors.joining(",")).split(",");
          }
      
          public EnumSet<Group.Role> getRolesAsEnumSet() {
              return EnumSet.copyOf(roles.stream().map(Group::getRole).collect(Collectors.toList()));
          }
      
          public boolean isAdmin() {
              return getRolesAsEnumSet().contains(Group.Role.ADMINISTRATOR);
          }
      }
    learner_created: true
  - name: src/account/security/IncorrectPasswordRecordRepository.java
    visible: true
    text: |
      package account.security;
      
      import org.springframework.data.repository.CrudRepository;
      
      public interface IncorrectPasswordRecordRepository extends CrudRepository<IncorrectPasswordRecord, Long> {
          IncorrectPasswordRecord findByUsernameIgnoreCase(String username);
      }
    learner_created: true
  - name: src/account/security/SecurityLog.java
    visible: true
    text: |
      package account.security;
      
      import jakarta.persistence.*;
      import lombok.Data;
      import lombok.NoArgsConstructor;
      
      import java.time.LocalDate;
      
      @Entity
      @Table(name = "security_logs")
      @Data
      @NoArgsConstructor
      public class SecurityLog {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private long id;
          private LocalDate date;
          private String action;
          private String subject;
          private String object;
          private String path;
      
          public SecurityLog(LocalDate date, String action, String subject, String object, String path) {
              this.date = date;
              this.action = action;
              this.subject = subject;
              this.object = object;
              this.path = path;
          }
      }
    learner_created: true
  - name: src/account/group/GroupLoader.java
    visible: true
    text: |
      package account.group;
      
      import org.springframework.stereotype.Component;
      
      @Component
      public class GroupLoader {
          private final GroupRepository groupRepository;
      
          public GroupLoader(GroupRepository groupRepository) {
              this.groupRepository = groupRepository;
      
              if (!groupRepository.isInitialisedWithRoles())
                  initialiseRoles();
          }
      
          private void initialiseRoles() {
              groupRepository.save(new Group(Group.Role.ADMINISTRATOR));
              groupRepository.save(new Group(Group.Role.ACCOUNTANT));
              groupRepository.save(new Group(Group.Role.USER));
              groupRepository.save(new Group(Group.Role.AUDITOR));
          }
      }
    learner_created: true
  - name: src/account/PasswordUtils.java
    visible: true
    text: |
      package account;
      
      import java.util.Arrays;
      
      public class PasswordUtils {
          public static boolean isPasswordTooShort(String password) {
              return Arrays.stream(password.split("")).filter(s -> !s.isBlank()).count() < 12;
          }
      
          public static boolean isBreachedPassword(String password) {
              return password.matches("PasswordFor((January)|(February)|(March)|(April)|(May)|(June)|(July)|(August)|(September)|(October)|(November)|(December))");
          }
      }
    learner_created: true
  - name: src/account/exceptions/NegativeSalaryException.java
    visible: true
    text: |
      package account.exceptions;
      
      public class NegativeSalaryException extends RuntimeException {
      }
    learner_created: true
  - name: src/resources/keystore/keystore.p12
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Fri, 05 Jan 2024 10:34:35 UTC"
record: -1
